- name: "[Prepare]: Deriving the chaos iterations"
  set_fact:
    c_iterations: "{{ (c_duration|int / c_interval|int)|int }}"
  when: c_iterations is not defined

- name: "[Prepare]: Deriving the chaos interval"
  set_fact:
    c_interval: "{{ (c_duration|int / c_iterations|int)|int }}"
  when: c_interval is not defined

- name: "[Prepare]: Setting the min chaos count to one"
  set_fact: 
    c_iterations: 1
  when: "c_iterations == '0'"

- block:

    - debug:
        msg: "***** Waiting for the ramp interval of {{ ramp_time }}s *****"

    - name: "[Ramp]: Waiting for the specified ramp time before injecting chaos"
      wait_for: timeout="{{ ramp_time }}"

  when: "ramp_time is defined and ramp_time != ''" 

- block:
    - name: "[Prepare]: Generate a run id if not passed from the engine/experiment"
      shell: echo $(mktemp) | cut -d '.' -f 2 | cut -c -6
      register: rand_string   

    - set_fact:
        run_id: "{{ rand_string.stdout | lower }}"
  when: "run_id is not defined or run_id == ''"

# This type variable is used to decide whether to check application status after each iteration 
# kill_random_pod will only check the application status if type is set to generic else skip
- name: "[Prepare]: Setting type to generic"
  set_fact:
    type: "generic" 

# chaos_status tracking the status of chaos, If it is active means chaos is in progress
# If it is terminate means chaos is ended.
- name: "[Prepare]: Setting the chaos_status to active"
  set_fact:
    chaos_status: "active" 

- block: 

  - name: "[Prepare]: Including the litmus LIB for random pod deletion"
    template:
      src:  /chaoslib/litmus/pod_delete/pod-delete.j2
      dest: /tmp/pod-delete-chaos.yml

  - name: "[Prepare]: Create helper pod for pod delete chaos"
    shell: kubectl create -f /tmp/pod-delete-chaos.yml -n {{ c_ns }}
    args:
      executable: /bin/bash
    register: helper_pod

  - name: "[Status]: Waiting for pod to come in Running state"
    shell: kubectl get pods -n {{ c_ns }} -l name=pod-delete-{{ run_id }} -o custom-columns=:.status.phase --no-headers
    register: status_result
    until: "'Running' in result.stdout"
    delay: 2
    retries: 90

  - name: "[Status]: Checking whether application pods are in completed state"
    shell: kubectl get pods -n {{ c_ns }} -l name=pod-delete-{{ run_id }} -o custom-columns=:.status.phase --no-headers
    register: result
    until: "'Running' not in result.stdout"
    delay: 1
    retries: "{{ c_duration }}"

  # chaosDiffTimeStamp contains the difference of current timestamp and start timestamp
  # it will helpful to track the run duration of healper pod
  - set_fact:
      chaosDiffTimeStamp: "{{ ((chaosCurrentTimeStamp | to_datetime) - (chaosStartTimeStamp | to_datetime)).total_seconds()  }}"

  - fail:
      msg: "pod-delete-chaos pod failed"
    when: "chaosDiffTimeStamp|int < c_duration|int"

  - name: "[CleanUP]: Delete Pod delete timestamp pod"
    shell: kubectl delete -f /tmp/pod-delete.yml -n {{ c_ns }}
    args:
      executable: /bin/bash

  # chaos_status tracking the status of chaos, If it is active means chaos is in progress
  # If it is terminate means chaos is ended.
  - name: "[Mark]: Setting chaos_status to terminate"
    set_fact:
      chaos_status: "terminate"

  when: "chaos_status is not defined or (chaos_status is defined and chaos_status == 'active')"

- block:
    - debug:
        msg: "***** Waiting for the ramp interval of {{ ramp_time }}s *****"

    - name: "[Ramp]: Waiting for the specified ramp time after injecting chaos"
      wait_for: timeout="{{ ramp_time }}"

  when: "ramp_time is defined and ramp_time != ''"