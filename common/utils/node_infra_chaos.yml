---

- block:
   - name: Create namespace for daemonset pod.
     shell: kubectl create  ns {{ daemon_namespace }}
     args:
       executable: /bin/bash
     register: dnamespace
     until: "'created' in dnamespace.stdout"
     delay: 5
     retries: 60

   - name: Create daemonset pods.
     shell: kubectl create -f {{daemonset}} -n {{daemon_namespace}}
     args:
      executable: /bin/bash
     register: daemonset
     until: "'created' in daemonset.stdout"
     delay: 5
     retries: 60

   - name: Check daemonset pods are up and running.
     shell: kubectl get pods -n {{ daemon_namespace }}  -o custom-columns=:status.phase --no-headers
     args:
       executable: /bin/bash
     register:  daemon_status
     until: "'Running' in daemon_status.stdout"
     delay: 5
     retries: 120

## Check the node name where application pod is running.
   - name: Obtain the node of running application pod .
     shell: kubectl get pod {{ Pod_name }} -o=custom-columns=:.spec.nodeName -n {{ application_namespace }} --no-headers
     args:
       executable: /bin/bash
     register: node_name

   - name: Recording the application pod node name.
     set_fact:
       node_name: "{{ node_name.stdout }}"

   - name: Obtain the daemonset pod name running on same application pod node.
     shell: >
        kubectl get pods --field-selector spec.nodeName={{node_name}}
        -o custom-columns=:.metadata.name -n {{daemon_namespace}} --no-headers
     args:
       executable: /bin/bash
     register: daemonset_name

   - name: Recording the daemonset pod node name.
     set_fact:
       daemonset_pod: "{{daemonset_name.stdout}}"

   - name: Generate the io using memleak script.
     shell:  >
       kubectl exec  {{daemonset_pod}} -n {{ daemon_namespace }}
       docker run {{io_script_image}} python memleak.py &

   - name: Wait for {{ (io_minutes) | int *60 }} secs for memory consumption.
     wait_for:
        timeout: "{{ (io_minutes) | int *60 }}"


   - name: Check the node status of daemonset pod and application pod.
     shell: kubectl get node {{node_name}} --no-headers | awk '{print $2}'
     args:
       executable: /bin/bash
     register: Node_status
     until: "'NotReady' in Node_status.stdout"
     delay: 5
     retries: 60

   
     ### Check for application pod status #####

   - include_tasks: "/common/utils/status_app_pod.yml"
     vars:
        delay: 5
        retries: 60

     ###### Check for the container status of  pod #######

   - name: Checking container status of affected application pod.
     shell: >
         kubectl get pods  -n   {{ app_ns }}
         -o jsonpath='{.items[?(@.metadata.labels.{{app_lkey}}=="{{app_lvalue}}")].status.containerStatuses[*].state}'
     args:
       executable: /bin/bash
     register: Container_status
     until: "'running' not  in Container_status.stdout"
     delay: 5
     retries: 120
  


